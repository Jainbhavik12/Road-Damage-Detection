# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yrzYXhijpGRtmDebDP0bhA4Og9IRy8oT
"""

!pip install ultralytics

import os
import cv2
import numpy as np
from PIL import Image
from ultralytics import YOLO

# Define constants
DATASET_PATH = '/content/drive/MyDrive/Dataset'
CLASS_NAMES = ['pothole', 'Alligator cracking', 'lateral cracking', 'logitudinal cracking']
MODEL_NAME = 'yolov3.pt'
EPOCHS = 100
BATCH_SIZE = 16
LEARNING_RATE = 0.001
TRAINING_NAME = 'road_damage_detection'
NUM_CLASSES = len(CLASS_NAMES)

# Create a YAML file for dataset configuration
DATA_YAML_PATH = os.path.join(DATASET_PATH, 'data.yaml')
with open(DATA_YAML_PATH, 'w') as f:
    f.write(f'train: {DATASET_PATH}\n')
    f.write(f'val: {DATASET_PATH}  # Optional: create a separate validation set\n')
    f.write(f'nc: {NUM_CLASSES}\n')
    f.write(f'names: {CLASS_NAMES}\n')

print("Starting Training...")
try:
    model = YOLO(MODEL_NAME)
    results = model.train(
        data=DATA_YAML_PATH,
        epochs=EPOCHS,
        batch=BATCH_SIZE,
        lr0=LEARNING_RATE,
        name=TRAINING_NAME
    )
    print("Training Finished.")
except Exception as e:
    print(f"Error during training: {e}")
    exit()

def run_real_time_detection(video_source=0, save_output=False):
    detector = RoadDamageDetector(trained_model_path, CLASS_NAMES)

    cap = cv2.VideoCapture(video_source)  # ‚úÖ Fixed line

    if not cap.isOpened():
        print("‚ùå Could not open video source.")
        return

    writer = None
    if save_output:
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        fps = cap.get(cv2.CAP_PROP_FPS)
        output_path = 'road_damage_output.avi'
        fourcc = cv2.VideoWriter_fourcc(*'XVID')
        writer = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        detections = detector.detect_damage(frame)
        annotated_frame = detector.visualize_detections(frame, detections)

        from google.colab.patches import cv2_imshow
        cv2_imshow(annotated_frame)

        if save_output and writer is not None:
            writer.write(annotated_frame)

    cap.release()
    if writer:
        writer.release()
    print("‚úÖ Detection completed.")

if __name__ == "__main__":
    run_real_time_detection(video_source='/content/0444.mp4', save_output=True)

import os
import cv2
import numpy as np
from PIL import Image
from ultralytics import YOLO
from google.colab.patches import cv2_imshow  # ‚úÖ Use this for Colab

# Constants
CLASS_NAMES = ['pothole', 'Alligator cracking', 'lateral cracking', 'logitudinal cracking']
TRAINING_NAME = 'road_damage_detection'
trained_model_path = os.path.join('runs', 'detect', TRAINING_NAME, 'weights', 'best.pt')

class RoadDamageDetector:
    def __init__(self, model_path, class_names):
        try:
            self.model = YOLO(model_path)
            self.model.eval()
            self.classes = class_names
            print(f"‚úÖ Model loaded from: {model_path}")
        except Exception as e:
            raise Exception(f"‚ùå Error loading model: {e}")

    def detect_damage(self, image):
        if isinstance(image, np.ndarray):
            image_pil = Image.fromarray(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        else:
            image_pil = image

        results = self.model(image_pil)

        detections = []
        if results and hasattr(results[0], 'boxes') and results[0].boxes is not None:
            for box in results[0].boxes.data.tolist():
                x_min, y_min, x_max, y_max, conf, cls = box
                detections.append({
                    'bbox': [int(x_min), int(y_min), int(x_max), int(y_max)],
                    'confidence': float(conf),
                    'class': self.classes[int(cls)]
                })
        return detections

    def visualize_detections(self, image, detections):
        annotated = image.copy()
        for detection in detections:
            x_min, y_min, x_max, y_max = detection['bbox']
            confidence = detection['confidence']
            class_name = detection['class']
            label = f'{class_name}: {confidence:.2f}'
            cv2.rectangle(annotated, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
            cv2.putText(annotated, label, (x_min, y_min - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        return annotated

def detect_damage_from_image(image_path):
    detector = RoadDamageDetector(trained_model_path, CLASS_NAMES)

    image = cv2.imread(image_path)
    if image is None:
        print(f"‚ùå Failed to load image from: {image_path}")
        return

    detections = detector.detect_damage(image)

    if detections:
        print("üìç Detected Road Damages:")
        for d in detections:
            print(f"  ‚û§ {d['class']} | Confidence: {d['confidence']:.2f} | BBox: {d['bbox']}")
    else:
        print("‚úÖ No road damage detected in the image.")

    annotated = detector.visualize_detections(image, detections)

    # ‚úÖ Show image in Colab
    cv2_imshow(annotated)

# Run detection
if __name__ == "__main__":
    image_path = "/content/roadimg1.jpg"  # Replace with your image path
    detect_damage_from_image(image_path)

